## Technical takehome challenge

## Documentation

CAUTION!: I wanted use this space to summarise the solution I implemented, just to be clear what my interpretation was.

The challenge was composed of three contracts:

- Token: Pausable, Mintable and Burnable ERC20 token

- Staking:

  - A staking contract that could be used for dynamic and static: I enterpreted dynamic staking as that one in which the user generates rewards depending on the offer of staking is currently in the pool. The more people are staking the lesser rewards are generated by each user

  - A staking contract that could implement auto-compounding and not: Auto-compounding is the characterist of an staking contract to sets the user default action to keep their rewards staked instead of withdrawing them.

- Proxy: This proxy will implement the upgradability for out Staking contract. Basically, we have separed the state from the logic. The state is on the Proxy contract and the logic is our staking contract. Internally, what the proxy contract does is to ask what would the staking contract do if the staking contract had the Proxy's state. This target address, for us the staking contract, can be updated by the proxy's owner, in this case me. üòÑ

## How to use?

Just for checking out the code is alrightü§ì

‚ö†Ô∏èYou need Foundry to be installed ‚ö†Ô∏è

```
forge test
```

Contracts are available in the following addresses:

- Token: [0x5d0b10a2e96f3150112e2c71a51b85b8dcebc89a](https://mumbai.polygonscan.com/address/0x5d0b10a2e96f3150112e2c71a51b85b8dcebc89a)
- Staking logic instance: [0x6bbe3ca92116dd2d2574ce3fc2211add6e811140](https://mumbai.polygonscan.com/address/0x6bbe3ca92116dd2d2574ce3fc2211add6e811140)
- Staking proxy: [0x291907cfe849e2364657e0c17bdc9ac5e619e26c](https://mumbai.polygonscan.com/address/0x291907cfe849e2364657e0c17bdc9ac5e619e26c)

Staking logic instance has been initalized as the target address of the proxy. But the initialize function is yet to be called with the desired parameters.
